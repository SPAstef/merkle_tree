\section{ZK-SNARK systems}\label{sec:zksnark}
We saw in Section~\ref{sec:vanilla} how a prover can convince a verifier about the knowledge of
some message \(m\), with a high confidence and a small communication effort, by using a CHF \(H\).
However, the underlying assumption was that \(m\) is known by the verifier: when the prover sends
\(h\), the verifier can check whether \(H(m) = h\) and therefore accept or reject.
\begin{definition}[Zero-Knowledge Proof]
	Given two parties, called the prover \(P\) and the verifier \(V\), a secret \(x\), known only to
	\(P\), and some statement \(\sigma \) of whose truth \(P\) wants to convince \(V\) by means of
	some proof \(\pi \), we call a Zero-Knowledge Proof (ZKP) system any protocol which satisfies the
	following properties:
	\begin{itemize}
		\item \textbf{Soundness}: \(\neg{\sigma} \implies V(\pi) = \bot \).
		\item \textbf{Completeness}: \(\sigma \implies V(\pi) = \top \).
		\item \textbf{Zero-Knowledge}: It is \emph{hard} for \(V\) to derive \(x\) given \(\sigma \)
		      and \(\pi \).
	\end{itemize}
\end{definition}

\noindent While formal proofs have been known for millenia, only in the last century, with the
advent of modern cryptography, researchers started considering the possibility of having proofs
of statements which, while able to convice someone of their truth, didn't leak information
about how they were obtained.
Zero-Knowledge systems proves particularly useful in \emph{ARgument of Knowledge} (ARK) scenarios
(together, they are called ZK-ARK): the prover \(P\) wants to convince the verifier \(V\) that he
knows a solution to some problem, assuming there is one, without revealing the solution itself.
For example, \(P\) might want to convince \(V\) that he knows an assignment of \(x\) which
satisfies the equation:
\[x^2 - 3x + 2 = 0\]
without revealing the assignment.
Of course, in this example it would be easy for \(V\) to find the solutions \( \{1, 2\} \),
reconstruct the proof, and finally discern which of the two solutions was known by \(P\).
We assume some familiarity with Turing machines, the Turing thesis and the
\(\Ptime \stackrel{?}{=} \NPtime \) question, but we'll quickly recall the parts which are most
important for us: an \NPcomp\ problem is a problem for which it is (thought to be) hard to find
solutions but it is easy to verify that an alleged solution is in fact one.
A ZK-ARK system would allow \(P\) to convince \(V\) that he knows a
solution to an instance of some \NPcomp\ problem, without giving it away.
For example, if \(P\) wants to prove that he knows some value of \(x\) which satisfies the equation:
\[F(x) = 0\]
where \(F\) is a OWF, it would be too hard for \(V\) to do what we discussed in the previous example
to retrieve the value of \(x\) known by \(P\).
It must be noted though that known ZK-ARK systems though do not guarantee the formal soundness of
the proof: there is a small probability that, given some false statement \(\sigma \) and an
(invalid) proof \(\pi \), then \(V(\pi) = \top \), but this probability is usually in the order of
\(2^{-128}\) or even less.
There are other nice additional properties that zero-knowledge systems might satisfy, making
them even more interesting.
\begin{definition}[ZK-SNARK]
	Given a prover \(P\), a verifier \(V\), a statement \(\sigma \), and a ZK-ARK system to produce
	a proof \(\pi \), if the system is:
	\begin{itemize}
		\item \textbf{Succint}: \(SPACE(\pi) = \SmallO(\log(\sigma))\).
		\item \textbf{Non-interactive}: The only communication required by the system is the exchange
		      of \(\sigma \) and \(\pi \).
	\end{itemize}
	then it is a Zero-Knowledge Non-interactive ARgument of Knowledge (ZK-SNARK) system.
\end{definition}

\noindent Succintness is an important property in a blockchain scenario, since we cannot
afford to use too much space to store the proofs, and non-interactivity of the process allows for
efficient verification when multiple parties are involved.

One of the most important applications of ZK-SNARK systems is in \emph{provable computation},
where the prover wants to convince the verifier that he correctly performed some computation
(e.g.\ a cryptocurrency transaction).
A very famous ZK-SNARK system for verifiable computation is the \emph{Pinocchio} protocol,
which was the first one efficient enough to be practical.

\subsection{The Pinocchio Protocol}
Pinocchio is composed of many different components, and requires quite a bit of mathematical
background to be fully understood. We will not go into all of the mathematical and cryptographic
details of the protocol, especially the ones involving \emph{elliptic curves},
but we will still try to give a good idea of how the protocol works, and ultimately what
determines its computational complexity.
\begin{definition}[Prime field]
	Given a prime number \(p\), the associated prime field is the set
	\(\mathbb{F}_p = \{ \{0, \dots, p - 1\}, \oplus, \otimes \} \), where \(\oplus \) is integer
	addition modulo \(p\) and \(\otimes \) is integer multiplication modulo \(p\).
\end{definition}

\noindent For ease of notation, we will often use \(+\) in place of \(\oplus \) and omit
\(\otimes \) if it is clear from the context.

\begin{definition}[Arithmetic circuit]
	Given a field \(\mathbb{F}\), some \(n, m \in \mathbb{N}\), some constants
	\(a_{1, 1}, \dots, a_{m, n} \in \mathbb{F}\), and some variables \(x_1, \dots, x_n \) over
	\(\mathbb{F}\), an arithmetic circuit over \(\mathbb{F}\) is any formula \(\phi \) of the type:
	\begin{align*}
		 & \phi \equiv c                    &  & \textnormal{with \(c \in \mathbb{F}\)}
		\\
		 & \phi \equiv x                    &  & \textnormal{with \(x\) variable over \(\mathbb{F}\)}
		\\
		 & \phi \equiv \phi' \oplus \phi''  &  & \textnormal{with \(\phi'\) and \(\phi''\) arithmetic
			circuits}
		\\
		 & \phi \equiv \phi' \otimes \phi'' &  & \textnormal{with \(\phi'\) and \(\phi''\) arithmetic
			circuits}
	\end{align*}
\end{definition}

\noindent Every arithmetic circuit can be represented by a Directed Acyclic Graph (DAG), where the
vertices are labeled either with a variable, a constant or one of the operations \(\oplus \) and
\(\otimes \): in the latter case, the vertex must have exactly two incoming edges which come from
the vertices representing the inputs of the operation.

Pinocchio does not allow the encoding of arbitrary languages, i.e.\ it is not Turing complete, but
we are restricted to arithmetic circuits over an arbitrary prime field \(\mathbb{F}_p\).
The main limitation arising from this restriction is that we cannot express unbounded computation
(e.g.\ loops whose exit condition depends on some non-constant value) in this framework.
This issue can be mitigated by writing a circuit compiler in a Turing complete language which
is able to synthesize parametrized arithmetic circuits on the fly.

\begin{definition}[Rank-1 Contraint System]
	Given a field \(\mathbb{F}\) and some \(m, n \in \mathbb{N}\), any set:
	\[ \{(a_1, b_1, c_1), \dots, (a_n, b_n, c_n) \mid \forall i\colon a_i, b_i, c_i \in
		\mathbb{F}^m\} \]
	is an \(n/m\) Rank-1 Constraint System (R1CS) over \(\mathbb{F}\).
	Given an R1CS \(\mathcal{C}\), a \emph{solution} to \(\mathcal{C}\) is any vector:
	\[ s \mid s \in \mathbb{F}^m \wedge \forall i\colon (s \cdot a_i)(s \cdot b_i) = s \cdot c_i \]
	where \(\cdot \) is the dot product operation.
\end{definition}

\noindent Fundamentally, an R1CS is a system of linear equations.
Any arithmetic circuit with \(n\) multiplicative gates and \(m-1\) variables can be associated with
an \(n/m\) R1CS (the extra variable is the constant \(1\) of the chosen field) in the following way:
\begin{enumerate}
	\item Multiplications by constants are unrolled into chains of additions.
	\item Chains of addition nodes are collapsed at multiplicative nodes.
	\item \(\forall i,j\colon a_{i,j}\) will contain the coefficient with which the \(j\)th variable
	      is input to the \emph{left} of the \(i\)th multiplicative gate.
	\item \(\forall i,j\colon b_{i,j}\) will contain the coefficient with which the \(j\)th variable
	      is input to the \emph{right} \(i\)th multiplicative gate.
	\item \(\forall i,j\colon c_{i,j}\) will contain the coefficient with which the \(j\)th variable
	      is output from the \(i\)th multiplicative gate.
\end{enumerate}

\noindent Let's make an example to better understand the process.
\begin{example}
	We have the prime field \(\mathbb{F}_{13}\) and want to compute the function:
	\[f(x_1, x_2) = x_2(x_1^3 + 4x_2 + 5)\]
	The corresponding arithmetic circuit is:
	\[x_2(x_1x_1x_1 + 4x_2 + 5)\]
	Note that \(4x_2 = x_2 + x_2 + x_2 + x_2\), so multiplications by constants don't really count as
	multiplications!
	Let's explicit all the intermediate variables (i.e.\ the outputs of the multiplications):
	\begin{align*}
		 & t_1 = x_1x_1 &  & t_2 = t_1x_1 + 4x_2 + 5 &  & y = t_2x_2
	\end{align*}
	We can see that there is a total of 3 multiplication gates and 5 variables
	(two input, two intermediates, one output), plus the implicit variable representing the constant
	\(1\).
	We can now build the associated \(3/6\) R1CS\@.
	The first constraint of the system is:
	\begin{align*}
		 & a_1 = (0, 1, 0, 0, 0, 0) &  & b_1 = (0, 1, 0, 0, 0, 0) &  & c_1 = (0, 0, 0, 1, 0, 0)
	\end{align*}
	Since we are multiplying \(x_1\) (represented by the second element in the vectors) by itself and
	putting it into \(t_1\), which is the fourth element.
	Similarly, we build the remaining constraints:
	\begin{align*}
		 & a_2 = (0, 0, 0, 1, 0, 0) &  & b_2 = (0, 1, 0, 0, 0, 0) &  & c_2 = (8, 0, 9, 0, 1, 0) \\
		 & a_3 = (0, 0, 0, 0, 1, 0) &  & b_3 = (0, 0, 1, 0, 0, 0) &  & c_3 = (0, 0, 0, 0, 0, 1)
	\end{align*}
	\((a_2, b_2, c_2)\) might confuse at first, but it is easy to derive once we see that:
	\[{t_2 = t_1x_1 + 4x_2 + 5} \iff {t_2 - 4x_2 - 5 = t_1x_1} \iff 8 + 9x_2 + t_2 = t_1x_1\]
	Remember that we are working over \(\mathbb{F}_{13}\): \(-4 \equiv 9\) and \(-5 \equiv 8\).
	With this, we have successfully built our target R1CS\@.

	Suppose now that we want to prove that we know \(x_1, x_2\) such that \(y = f(x_1, x_2) = 10\).
	For example, \(x_1 = 2, x_2 = 3\) are valid choices, since:
	\[3(2^3 + 4\times3 + 5) = 75 \equiv 10 \pmod{13}\]
	After computing the intermediates values \(t_1 = 4\) and \(t_2 = 25 \equiv 12 \pmod{13}\),
	we can find the solution:
	\[ s = (1, 2, 3, 4, 12, 10) \]
\end{example}

\noindent The reason we translate arithmetic circuits into R1CS is that they explicit all of the
computation in terms of linear combinations, which allows us to use Lagrange interpolation to
build polynomials over them.

\begin{definition}[Polynomial fields]
	Given a field \(\mathbb{F}\), some \(n \in \mathbb{N}\) and some
	\(d_1, \dots, d_n \in \mathbb{N}\), we denote with \(\mathbb{F}[x_1^{d_1}, \dots, x_n^{d_n}]\)
	the set of all \(n\)-variate polynomials in \(\mathbb{F}\) over variables \(x_1, \dots, x_n\)
	each with maximum degree \(d_1, \dots, d_n\).
\end{definition}

\begin{definition}[Quadratic Arithmetic Program]
	Given a field \(\mathbb{F}\) and some \(n,m \in \mathbb{N}\), any set:
	\[ \{t, \{v_1, \dots, v_n\}, \{w_1, \dots, w_n\}, \{y_1, \dots, y_n\} \} \mid
		t \in \mathbb{F}[x^m] \wedge \forall i\colon v_i, w_i, y_i \in \mathbb{F}[x^{m-1}]\]
	is an Quadratic Arithmetic Program (QAP) over \(\mathbb{F}\).
\end{definition}

\noindent
With all this in mind, the flow of the Pinocchio protocol is as follows:
\begin{enumerate}
	\item Encode an algorithm as an arithmetic circuit over some prime field \(\mathbb{F}_p\).
	\item Compute the associated R1CS\@.
	\item Compute the associated QAP\@.
	\item Generate random values and instantiate an homomorphic encryption mapping
	      (using elliptic curves) which depends on those values.
	\item Generate the proof by encrypting the QAP with the homomorphic mapping.
	\item Map again the proof to a new homomorphic space, and finally verify it.
\end{enumerate}

\noindent Due to the homomorphism of the mappings and the properties of QAPs and R1CSs, if the
verification is successful, it means that the original algorithm was in fact correctly executed,
with high probability.
If the verification fails, then certainly the original algorithm was not executed correctly.
The verifier learns cannot learn any additional information from this process without performing
an infeasible amount of work, therefore this is indeed a ZK-SNARK protocol.
