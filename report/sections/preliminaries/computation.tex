\subsection{Computational models and complexity}
A \emph{computational model} (or model of computation) is any kind of `device', either physical or
mathematical, which is able to compute algorithms to solve problems~\cite{Savage1997}.
A particularly interesting class of problems are \emph{decision problems}, the ones that can be
answered with `yes' (or `accept', or \(\top \)) or `no' (or `reject', or \(\bot \)).
Every computational model is able to \emph{decide} only a subclass of all decision problems, and
even then, not all can be solved \emph{efficiently}, that is, by using an amount of resources
(typically, time and space) which is upper-bounded by some polynomial function of the input length.
Problems for which a polynomial bound doesen’t exist or isn’t known are said to be \emph{hard} for 
the computational model. 
For example, finding solutions to boolean equations (the \textsc{sat} problem) and, by extension, 
to arithmetic equations, is believed to be hard for deterministic Turing machines, but it is easy 
for non-deterministic ones~\cite{Cook1971}. 
With the advent of quantum-computing, problems which are believed to be hard for
classical computers, like prime factorization, have been shown to be efficiently
solved by quantum computers~\cite{Shor1994}. While still far from usable in practical cases,
this shows that one must be extremely careful when talking about the hardness
of problems, especially when applied to cryptography, and must always make
clear assumptions on the underlying model of computation.
