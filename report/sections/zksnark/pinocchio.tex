\subsection{The Pinocchio Protocol}
A very famous ZK-SNARK system for verifiable computation is the \emph{Pinocchio} protocol,
which was the first one efficient enough to be practical.
Pinocchio uses a lot of mathematical machinery, and it's not trivial to fully understand
\emph{how}, and even more importantly, \emph{why}, it actually works.
We will not go into all of the details of the protocol, especially in the last stages which involve
\emph{elliptic curve} mathematics, but we will still try to give a good idea of the first stages
and an intuition of the last ones, focusing on what determines the computational complexity of
this protocol.

Pinocchio does not allow the encoding of arbitrary languages, i.e.\ it is not Turing complete, but
we are restricted to arithmetic circuits over some prime field \(\mathbb{F}_p\).
The main limitation arising from this restriction is that we cannot express unbounded computation
(like infinite loops) or even variably-bounded computation (like loops whose exit condition
depends on some non-constant value).
This issue can be mitigated by writing a \emph{circuit synthesizer} in a Turing complete language
which is able to build parametrized arithmetic circuits `on the fly'.
After we have our arithmetic circuit \(\phi \) over a prime field \(\mathbb{F}_p\), the Pinocchio
works as follows:
\begin{enumerate}
	\item The circuit \(\phi \) is made public.
	\item Build the R1CS \(\mathcal{C}\) associated with \(\phi \).
	\item Build the QAP \(\mathcal{Q}\) associated with \(\mathcal{C}\).
	\item A trusted third party generates some random data, which is used to create a prover key
	      (\(k_P\)) and a verifier key \(k_V\). The random data must be kept secret
	      (or even better, deleted after use).
	\item The prover executes \(\phi \), computes all the intermediate values, and uses them to
	      solve \(\mathcal{C}\) and \(\mathcal{Q}\); in the end, he finds a solution \((p, h)\)
	      for \(\mathcal{Q}\).
	\item The prover chooses some value \(x\) to compute \(p(x)\) and \(h(x)\), and uses \(k_P\)
	      to generate an encrypted proof, of size \(\BigO(1)\), which is sent to the verifier.
	      The encryption scheme exploits group theory so that \(p(x) = h(x)t(x)\) if and only if
	      a different (but still easy) operation involving the encrypted values holds in the
	      encrypted space.
	      This involves using a public cyclic group 
        \(\mathbb{G}_q = ({\{g^i \bmod q\}}_{i \in \mathbb{F}_p}, \otimes)\) which is generated by 
        some public element \(g \in \mathbb{F}_p\) and a 
        prime number \(q \in \mathbb{N}\), together with a bilinear mapping
	      \(B\colon \mathbb{G}_q \times \mathbb{G}_q \mapsto \mathbb{F}_q\) (bilinear means that
	      \(B(x^a, y^b) = {B(x, y)}^{ab}\)).
	      The group \(\mathbb{G}_q\) was also used to generate \(k_P\) and \(k_V\).
	\item
\end{enumerate}

\noindent Due to the homomorphism of the mappings and the properties of QAPs and R1CSs, if the
verification is successful, it means that the original algorithm was in fact correctly executed,
with high probability.
If the verification fails, then certainly the original algorithm was not executed correctly.
The verifier learns cannot learn any additional information from this process without performing
an infeasible amount of work, therefore this is indeed a ZK-SNARK protocol.
